### 模式三 单例模式
```go
package main

import (
	"sync"
	"fmt"
)

type singleton map[string]string

var (
	once     sync.Once
	instance singleton
)

func New() singleton {
	once.Do(func() {
		instance = make(singleton)
	})
	return instance
}

func main() {
	s := New()
	s["test1"] = "dafd"
	s["test2"] = "fff"
	fmt.Println(s)
}
```

### 总结

#### 目的

>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；
一个系统只能有一个计时工具或ID（序号）生成器。
 
>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。
 
> 一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。

#### 定义

>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，
这个类称为单例类，它提供全局访问的方法。
 
>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。
单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。

#### 结构

* Singleton：单例

![](https://github.com/developersPHP/design-patterns-go/blob/master/images/Singleton.jpg)

#### 时序图

![](https://github.com/developersPHP/design-patterns-go/blob/master/images/seq_Singleton.jpg)

#### 分析

>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，
就是单例类——Singleton。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，
该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，
然后存储在静态成员变量中，以确保只有一个实例被创建。

>在单例模式的实现过程中，需要注意如下三点：

* 单例类的构造函数为私有；
* 提供一个自身的静态私有成员变量；
* 提供一个公有的静态工厂方法。

#### 实例
>在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、
中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。
现使用单例模式来模拟实现打印池的设计。

#### 优点

* 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，
并为设计及开发团队提供了共享的概念

* 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
* 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。

#### 缺点
* 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
* 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，
将产品的创建和产品的本身的功能融合到一起。

* 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，
因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，
下次利用时又将重新实例化，这将导致对象状态的丢失。

#### 适用场景

* 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
* 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。
* 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式

#### 应用实例

>一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。
>在整个项目中需要一个共享访问点或共享数据，例如一个web页面上的计数器，可以不用把每次刷新都记录到数据库，使用单例模式保持计数器值，并确保是线程安全的
>创建一个对象需要耗费的资源过多，如访问IO，数据库资源等
>需要定义大量的静态常量或静态方法
#### 注意点
* 在高并发情况下，请注意单例模式的线程同步问题
* 注意垃圾回收对对象的影响





